// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fish.proto

#ifndef PROTOBUF_fish_2eproto__INCLUDED
#define PROTOBUF_fish_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace fish {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_fish_2eproto();
void protobuf_AssignDesc_fish_2eproto();
void protobuf_ShutdownFile_fish_2eproto();

class packet;
class ping_req;
class ping_rsp;
class login_req;
class login_rsp;
class enter_room_req;
class seat;
class enter_room_rsp;
class enter_room_notify;
class fire_req;
class fire_rsp;
class fire_notify;
class fish_refresh_notify;

enum cmd {
  CMD_PING_REQ = 100,
  CMD_PING_RSP = 101,
  CMD_LOGIN_REQ = 1001,
  CMD_LOGIN_RSP = 1002,
  CMD_ENTER_ROOM_REQ = 1003,
  CMD_ENTER_ROOM_RSP = 1004,
  CMD_ENTER_ROOM_NOTIFY = 1005,
  CMD_FIRE_REQ = 1006,
  CMD_FIRE_RSP = 1007,
  CMD_FIRE_NOTIFY = 1008,
  CMD_FISH_REFRESH_NOTIFY = 1009
};
bool cmd_IsValid(int value);
const cmd cmd_MIN = CMD_PING_REQ;
const cmd cmd_MAX = CMD_FISH_REFRESH_NOTIFY;
const int cmd_ARRAYSIZE = cmd_MAX + 1;

const ::google::protobuf::EnumDescriptor* cmd_descriptor();
inline const ::std::string& cmd_Name(cmd value) {
  return ::google::protobuf::internal::NameOfEnum(
    cmd_descriptor(), value);
}
inline bool cmd_Parse(
    const ::std::string& name, cmd* value) {
  return ::google::protobuf::internal::ParseNamedEnum<cmd>(
    cmd_descriptor(), name, value);
}
// ===================================================================

class packet : public ::google::protobuf::Message {
 public:
  packet();
  virtual ~packet();

  packet(const packet& from);

  inline packet& operator=(const packet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const packet& default_instance();

  void Swap(packet* other);

  // implements Message ----------------------------------------------

  packet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const packet& from);
  void MergeFrom(const packet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);

  // required bytes body = 3;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 3;
  inline const ::std::string& body() const;
  inline void set_body(const ::std::string& value);
  inline void set_body(const char* value);
  inline void set_body(const void* value, size_t size);
  inline ::std::string* mutable_body();
  inline ::std::string* release_body();
  inline void set_allocated_body(::std::string* body);

  // @@protoc_insertion_point(class_scope:fish.packet)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_body();
  inline void clear_has_body();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* body_;
  ::google::protobuf::int32 cmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_fish_2eproto();
  friend void protobuf_AssignDesc_fish_2eproto();
  friend void protobuf_ShutdownFile_fish_2eproto();

  void InitAsDefaultInstance();
  static packet* default_instance_;
};
// -------------------------------------------------------------------

class ping_req : public ::google::protobuf::Message {
 public:
  ping_req();
  virtual ~ping_req();

  ping_req(const ping_req& from);

  inline ping_req& operator=(const ping_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ping_req& default_instance();

  void Swap(ping_req* other);

  // implements Message ----------------------------------------------

  ping_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ping_req& from);
  void MergeFrom(const ping_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fish.ping_req)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_fish_2eproto();
  friend void protobuf_AssignDesc_fish_2eproto();
  friend void protobuf_ShutdownFile_fish_2eproto();

  void InitAsDefaultInstance();
  static ping_req* default_instance_;
};
// -------------------------------------------------------------------

class ping_rsp : public ::google::protobuf::Message {
 public:
  ping_rsp();
  virtual ~ping_rsp();

  ping_rsp(const ping_rsp& from);

  inline ping_rsp& operator=(const ping_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ping_rsp& default_instance();

  void Swap(ping_rsp* other);

  // implements Message ----------------------------------------------

  ping_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ping_rsp& from);
  void MergeFrom(const ping_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fish.ping_rsp)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_fish_2eproto();
  friend void protobuf_AssignDesc_fish_2eproto();
  friend void protobuf_ShutdownFile_fish_2eproto();

  void InitAsDefaultInstance();
  static ping_rsp* default_instance_;
};
// -------------------------------------------------------------------

class login_req : public ::google::protobuf::Message {
 public:
  login_req();
  virtual ~login_req();

  login_req(const login_req& from);

  inline login_req& operator=(const login_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const login_req& default_instance();

  void Swap(login_req* other);

  // implements Message ----------------------------------------------

  login_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const login_req& from);
  void MergeFrom(const login_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string acc = 1;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 1;
  inline const ::std::string& acc() const;
  inline void set_acc(const ::std::string& value);
  inline void set_acc(const char* value);
  inline void set_acc(const char* value, size_t size);
  inline ::std::string* mutable_acc();
  inline ::std::string* release_acc();
  inline void set_allocated_acc(::std::string* acc);

  // required string pwd = 2;
  inline bool has_pwd() const;
  inline void clear_pwd();
  static const int kPwdFieldNumber = 2;
  inline const ::std::string& pwd() const;
  inline void set_pwd(const ::std::string& value);
  inline void set_pwd(const char* value);
  inline void set_pwd(const char* value, size_t size);
  inline ::std::string* mutable_pwd();
  inline ::std::string* release_pwd();
  inline void set_allocated_pwd(::std::string* pwd);

  // @@protoc_insertion_point(class_scope:fish.login_req)
 private:
  inline void set_has_acc();
  inline void clear_has_acc();
  inline void set_has_pwd();
  inline void clear_has_pwd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* acc_;
  ::std::string* pwd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_fish_2eproto();
  friend void protobuf_AssignDesc_fish_2eproto();
  friend void protobuf_ShutdownFile_fish_2eproto();

  void InitAsDefaultInstance();
  static login_req* default_instance_;
};
// -------------------------------------------------------------------

class login_rsp : public ::google::protobuf::Message {
 public:
  login_rsp();
  virtual ~login_rsp();

  login_rsp(const login_rsp& from);

  inline login_rsp& operator=(const login_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const login_rsp& default_instance();

  void Swap(login_rsp* other);

  // implements Message ----------------------------------------------

  login_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const login_rsp& from);
  void MergeFrom(const login_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional string game_id = 2;
  inline bool has_game_id() const;
  inline void clear_game_id();
  static const int kGameIdFieldNumber = 2;
  inline const ::std::string& game_id() const;
  inline void set_game_id(const ::std::string& value);
  inline void set_game_id(const char* value);
  inline void set_game_id(const char* value, size_t size);
  inline ::std::string* mutable_game_id();
  inline ::std::string* release_game_id();
  inline void set_allocated_game_id(::std::string* game_id);

  // repeated int32 room_type = 3;
  inline int room_type_size() const;
  inline void clear_room_type();
  static const int kRoomTypeFieldNumber = 3;
  inline ::google::protobuf::int32 room_type(int index) const;
  inline void set_room_type(int index, ::google::protobuf::int32 value);
  inline void add_room_type(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      room_type() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_room_type();

  // @@protoc_insertion_point(class_scope:fish.login_rsp)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_game_id();
  inline void clear_has_game_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* game_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > room_type_;
  ::google::protobuf::int32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_fish_2eproto();
  friend void protobuf_AssignDesc_fish_2eproto();
  friend void protobuf_ShutdownFile_fish_2eproto();

  void InitAsDefaultInstance();
  static login_rsp* default_instance_;
};
// -------------------------------------------------------------------

class enter_room_req : public ::google::protobuf::Message {
 public:
  enter_room_req();
  virtual ~enter_room_req();

  enter_room_req(const enter_room_req& from);

  inline enter_room_req& operator=(const enter_room_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const enter_room_req& default_instance();

  void Swap(enter_room_req* other);

  // implements Message ----------------------------------------------

  enter_room_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const enter_room_req& from);
  void MergeFrom(const enter_room_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 room_type = 1;
  inline bool has_room_type() const;
  inline void clear_room_type();
  static const int kRoomTypeFieldNumber = 1;
  inline ::google::protobuf::int32 room_type() const;
  inline void set_room_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fish.enter_room_req)
 private:
  inline void set_has_room_type();
  inline void clear_has_room_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 room_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_fish_2eproto();
  friend void protobuf_AssignDesc_fish_2eproto();
  friend void protobuf_ShutdownFile_fish_2eproto();

  void InitAsDefaultInstance();
  static enter_room_req* default_instance_;
};
// -------------------------------------------------------------------

class seat : public ::google::protobuf::Message {
 public:
  seat();
  virtual ~seat();

  seat(const seat& from);

  inline seat& operator=(const seat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const seat& default_instance();

  void Swap(seat* other);

  // implements Message ----------------------------------------------

  seat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const seat& from);
  void MergeFrom(const seat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);

  // required string game_id = 2;
  inline bool has_game_id() const;
  inline void clear_game_id();
  static const int kGameIdFieldNumber = 2;
  inline const ::std::string& game_id() const;
  inline void set_game_id(const ::std::string& value);
  inline void set_game_id(const char* value);
  inline void set_game_id(const char* value, size_t size);
  inline ::std::string* mutable_game_id();
  inline ::std::string* release_game_id();
  inline void set_allocated_game_id(::std::string* game_id);

  // @@protoc_insertion_point(class_scope:fish.seat)
 private:
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_game_id();
  inline void clear_has_game_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* game_id_;
  ::google::protobuf::int32 number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_fish_2eproto();
  friend void protobuf_AssignDesc_fish_2eproto();
  friend void protobuf_ShutdownFile_fish_2eproto();

  void InitAsDefaultInstance();
  static seat* default_instance_;
};
// -------------------------------------------------------------------

class enter_room_rsp : public ::google::protobuf::Message {
 public:
  enter_room_rsp();
  virtual ~enter_room_rsp();

  enter_room_rsp(const enter_room_rsp& from);

  inline enter_room_rsp& operator=(const enter_room_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const enter_room_rsp& default_instance();

  void Swap(enter_room_rsp* other);

  // implements Message ----------------------------------------------

  enter_room_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const enter_room_rsp& from);
  void MergeFrom(const enter_room_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // repeated .fish.seat room_users = 2;
  inline int room_users_size() const;
  inline void clear_room_users();
  static const int kRoomUsersFieldNumber = 2;
  inline const ::fish::seat& room_users(int index) const;
  inline ::fish::seat* mutable_room_users(int index);
  inline ::fish::seat* add_room_users();
  inline const ::google::protobuf::RepeatedPtrField< ::fish::seat >&
      room_users() const;
  inline ::google::protobuf::RepeatedPtrField< ::fish::seat >*
      mutable_room_users();

  // @@protoc_insertion_point(class_scope:fish.enter_room_rsp)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::fish::seat > room_users_;
  ::google::protobuf::int32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_fish_2eproto();
  friend void protobuf_AssignDesc_fish_2eproto();
  friend void protobuf_ShutdownFile_fish_2eproto();

  void InitAsDefaultInstance();
  static enter_room_rsp* default_instance_;
};
// -------------------------------------------------------------------

class enter_room_notify : public ::google::protobuf::Message {
 public:
  enter_room_notify();
  virtual ~enter_room_notify();

  enter_room_notify(const enter_room_notify& from);

  inline enter_room_notify& operator=(const enter_room_notify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const enter_room_notify& default_instance();

  void Swap(enter_room_notify* other);

  // implements Message ----------------------------------------------

  enter_room_notify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const enter_room_notify& from);
  void MergeFrom(const enter_room_notify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);

  // required string game_id = 2;
  inline bool has_game_id() const;
  inline void clear_game_id();
  static const int kGameIdFieldNumber = 2;
  inline const ::std::string& game_id() const;
  inline void set_game_id(const ::std::string& value);
  inline void set_game_id(const char* value);
  inline void set_game_id(const char* value, size_t size);
  inline ::std::string* mutable_game_id();
  inline ::std::string* release_game_id();
  inline void set_allocated_game_id(::std::string* game_id);

  // @@protoc_insertion_point(class_scope:fish.enter_room_notify)
 private:
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_game_id();
  inline void clear_has_game_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* game_id_;
  ::google::protobuf::int32 number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_fish_2eproto();
  friend void protobuf_AssignDesc_fish_2eproto();
  friend void protobuf_ShutdownFile_fish_2eproto();

  void InitAsDefaultInstance();
  static enter_room_notify* default_instance_;
};
// -------------------------------------------------------------------

class fire_req : public ::google::protobuf::Message {
 public:
  fire_req();
  virtual ~fire_req();

  fire_req(const fire_req& from);

  inline fire_req& operator=(const fire_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fire_req& default_instance();

  void Swap(fire_req* other);

  // implements Message ----------------------------------------------

  fire_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fire_req& from);
  void MergeFrom(const fire_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 angle = 1;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 1;
  inline ::google::protobuf::int32 angle() const;
  inline void set_angle(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fish.fire_req)
 private:
  inline void set_has_angle();
  inline void clear_has_angle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 angle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_fish_2eproto();
  friend void protobuf_AssignDesc_fish_2eproto();
  friend void protobuf_ShutdownFile_fish_2eproto();

  void InitAsDefaultInstance();
  static fire_req* default_instance_;
};
// -------------------------------------------------------------------

class fire_rsp : public ::google::protobuf::Message {
 public:
  fire_rsp();
  virtual ~fire_rsp();

  fire_rsp(const fire_rsp& from);

  inline fire_rsp& operator=(const fire_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fire_rsp& default_instance();

  void Swap(fire_rsp* other);

  // implements Message ----------------------------------------------

  fire_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fire_rsp& from);
  void MergeFrom(const fire_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fish.fire_rsp)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_fish_2eproto();
  friend void protobuf_AssignDesc_fish_2eproto();
  friend void protobuf_ShutdownFile_fish_2eproto();

  void InitAsDefaultInstance();
  static fire_rsp* default_instance_;
};
// -------------------------------------------------------------------

class fire_notify : public ::google::protobuf::Message {
 public:
  fire_notify();
  virtual ~fire_notify();

  fire_notify(const fire_notify& from);

  inline fire_notify& operator=(const fire_notify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fire_notify& default_instance();

  void Swap(fire_notify* other);

  // implements Message ----------------------------------------------

  fire_notify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fire_notify& from);
  void MergeFrom(const fire_notify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);

  // required int32 angle = 2;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 2;
  inline ::google::protobuf::int32 angle() const;
  inline void set_angle(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fish.fire_notify)
 private:
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_angle();
  inline void clear_has_angle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 number_;
  ::google::protobuf::int32 angle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_fish_2eproto();
  friend void protobuf_AssignDesc_fish_2eproto();
  friend void protobuf_ShutdownFile_fish_2eproto();

  void InitAsDefaultInstance();
  static fire_notify* default_instance_;
};
// -------------------------------------------------------------------

class fish_refresh_notify : public ::google::protobuf::Message {
 public:
  fish_refresh_notify();
  virtual ~fish_refresh_notify();

  fish_refresh_notify(const fish_refresh_notify& from);

  inline fish_refresh_notify& operator=(const fish_refresh_notify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fish_refresh_notify& default_instance();

  void Swap(fish_refresh_notify* other);

  // implements Message ----------------------------------------------

  fish_refresh_notify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fish_refresh_notify& from);
  void MergeFrom(const fish_refresh_notify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 fish_id = 1;
  inline bool has_fish_id() const;
  inline void clear_fish_id();
  static const int kFishIdFieldNumber = 1;
  inline ::google::protobuf::int32 fish_id() const;
  inline void set_fish_id(::google::protobuf::int32 value);

  // required int32 line_id = 2;
  inline bool has_line_id() const;
  inline void clear_line_id();
  static const int kLineIdFieldNumber = 2;
  inline ::google::protobuf::int32 line_id() const;
  inline void set_line_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fish.fish_refresh_notify)
 private:
  inline void set_has_fish_id();
  inline void clear_has_fish_id();
  inline void set_has_line_id();
  inline void clear_has_line_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 fish_id_;
  ::google::protobuf::int32 line_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_fish_2eproto();
  friend void protobuf_AssignDesc_fish_2eproto();
  friend void protobuf_ShutdownFile_fish_2eproto();

  void InitAsDefaultInstance();
  static fish_refresh_notify* default_instance_;
};
// ===================================================================


// ===================================================================

// packet

// required int32 cmd = 1;
inline bool packet::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void packet::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void packet::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void packet::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 packet::cmd() const {
  return cmd_;
}
inline void packet::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// required bytes body = 3;
inline bool packet::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void packet::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void packet::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void packet::clear_body() {
  if (body_ != &::google::protobuf::internal::kEmptyString) {
    body_->clear();
  }
  clear_has_body();
}
inline const ::std::string& packet::body() const {
  return *body_;
}
inline void packet::set_body(const ::std::string& value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(value);
}
inline void packet::set_body(const char* value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(value);
}
inline void packet::set_body(const void* value, size_t size) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* packet::mutable_body() {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  return body_;
}
inline ::std::string* packet::release_body() {
  clear_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = body_;
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void packet::set_allocated_body(::std::string* body) {
  if (body_ != &::google::protobuf::internal::kEmptyString) {
    delete body_;
  }
  if (body) {
    set_has_body();
    body_ = body;
  } else {
    clear_has_body();
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ping_req

// optional int32 id = 1;
inline bool ping_req::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ping_req::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ping_req::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ping_req::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ping_req::id() const {
  return id_;
}
inline void ping_req::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// ping_rsp

// optional int32 id = 1;
inline bool ping_rsp::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ping_rsp::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ping_rsp::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ping_rsp::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ping_rsp::id() const {
  return id_;
}
inline void ping_rsp::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// login_req

// required string acc = 1;
inline bool login_req::has_acc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void login_req::set_has_acc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void login_req::clear_has_acc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void login_req::clear_acc() {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    acc_->clear();
  }
  clear_has_acc();
}
inline const ::std::string& login_req::acc() const {
  return *acc_;
}
inline void login_req::set_acc(const ::std::string& value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void login_req::set_acc(const char* value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void login_req::set_acc(const char* value, size_t size) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* login_req::mutable_acc() {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  return acc_;
}
inline ::std::string* login_req::release_acc() {
  clear_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acc_;
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void login_req::set_allocated_acc(::std::string* acc) {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    delete acc_;
  }
  if (acc) {
    set_has_acc();
    acc_ = acc;
  } else {
    clear_has_acc();
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string pwd = 2;
inline bool login_req::has_pwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void login_req::set_has_pwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void login_req::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void login_req::clear_pwd() {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    pwd_->clear();
  }
  clear_has_pwd();
}
inline const ::std::string& login_req::pwd() const {
  return *pwd_;
}
inline void login_req::set_pwd(const ::std::string& value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void login_req::set_pwd(const char* value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void login_req::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* login_req::mutable_pwd() {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  return pwd_;
}
inline ::std::string* login_req::release_pwd() {
  clear_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pwd_;
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void login_req::set_allocated_pwd(::std::string* pwd) {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    delete pwd_;
  }
  if (pwd) {
    set_has_pwd();
    pwd_ = pwd;
  } else {
    clear_has_pwd();
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// login_rsp

// required int32 state = 1;
inline bool login_rsp::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void login_rsp::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void login_rsp::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void login_rsp::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 login_rsp::state() const {
  return state_;
}
inline void login_rsp::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// optional string game_id = 2;
inline bool login_rsp::has_game_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void login_rsp::set_has_game_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void login_rsp::clear_has_game_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void login_rsp::clear_game_id() {
  if (game_id_ != &::google::protobuf::internal::kEmptyString) {
    game_id_->clear();
  }
  clear_has_game_id();
}
inline const ::std::string& login_rsp::game_id() const {
  return *game_id_;
}
inline void login_rsp::set_game_id(const ::std::string& value) {
  set_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    game_id_ = new ::std::string;
  }
  game_id_->assign(value);
}
inline void login_rsp::set_game_id(const char* value) {
  set_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    game_id_ = new ::std::string;
  }
  game_id_->assign(value);
}
inline void login_rsp::set_game_id(const char* value, size_t size) {
  set_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    game_id_ = new ::std::string;
  }
  game_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* login_rsp::mutable_game_id() {
  set_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    game_id_ = new ::std::string;
  }
  return game_id_;
}
inline ::std::string* login_rsp::release_game_id() {
  clear_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = game_id_;
    game_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void login_rsp::set_allocated_game_id(::std::string* game_id) {
  if (game_id_ != &::google::protobuf::internal::kEmptyString) {
    delete game_id_;
  }
  if (game_id) {
    set_has_game_id();
    game_id_ = game_id;
  } else {
    clear_has_game_id();
    game_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated int32 room_type = 3;
inline int login_rsp::room_type_size() const {
  return room_type_.size();
}
inline void login_rsp::clear_room_type() {
  room_type_.Clear();
}
inline ::google::protobuf::int32 login_rsp::room_type(int index) const {
  return room_type_.Get(index);
}
inline void login_rsp::set_room_type(int index, ::google::protobuf::int32 value) {
  room_type_.Set(index, value);
}
inline void login_rsp::add_room_type(::google::protobuf::int32 value) {
  room_type_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
login_rsp::room_type() const {
  return room_type_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
login_rsp::mutable_room_type() {
  return &room_type_;
}

// -------------------------------------------------------------------

// enter_room_req

// required int32 room_type = 1;
inline bool enter_room_req::has_room_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void enter_room_req::set_has_room_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void enter_room_req::clear_has_room_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void enter_room_req::clear_room_type() {
  room_type_ = 0;
  clear_has_room_type();
}
inline ::google::protobuf::int32 enter_room_req::room_type() const {
  return room_type_;
}
inline void enter_room_req::set_room_type(::google::protobuf::int32 value) {
  set_has_room_type();
  room_type_ = value;
}

// -------------------------------------------------------------------

// seat

// required int32 number = 1;
inline bool seat::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void seat::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void seat::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void seat::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 seat::number() const {
  return number_;
}
inline void seat::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
}

// required string game_id = 2;
inline bool seat::has_game_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void seat::set_has_game_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void seat::clear_has_game_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void seat::clear_game_id() {
  if (game_id_ != &::google::protobuf::internal::kEmptyString) {
    game_id_->clear();
  }
  clear_has_game_id();
}
inline const ::std::string& seat::game_id() const {
  return *game_id_;
}
inline void seat::set_game_id(const ::std::string& value) {
  set_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    game_id_ = new ::std::string;
  }
  game_id_->assign(value);
}
inline void seat::set_game_id(const char* value) {
  set_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    game_id_ = new ::std::string;
  }
  game_id_->assign(value);
}
inline void seat::set_game_id(const char* value, size_t size) {
  set_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    game_id_ = new ::std::string;
  }
  game_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* seat::mutable_game_id() {
  set_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    game_id_ = new ::std::string;
  }
  return game_id_;
}
inline ::std::string* seat::release_game_id() {
  clear_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = game_id_;
    game_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void seat::set_allocated_game_id(::std::string* game_id) {
  if (game_id_ != &::google::protobuf::internal::kEmptyString) {
    delete game_id_;
  }
  if (game_id) {
    set_has_game_id();
    game_id_ = game_id;
  } else {
    clear_has_game_id();
    game_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// enter_room_rsp

// required int32 state = 1;
inline bool enter_room_rsp::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void enter_room_rsp::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void enter_room_rsp::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void enter_room_rsp::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 enter_room_rsp::state() const {
  return state_;
}
inline void enter_room_rsp::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// repeated .fish.seat room_users = 2;
inline int enter_room_rsp::room_users_size() const {
  return room_users_.size();
}
inline void enter_room_rsp::clear_room_users() {
  room_users_.Clear();
}
inline const ::fish::seat& enter_room_rsp::room_users(int index) const {
  return room_users_.Get(index);
}
inline ::fish::seat* enter_room_rsp::mutable_room_users(int index) {
  return room_users_.Mutable(index);
}
inline ::fish::seat* enter_room_rsp::add_room_users() {
  return room_users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fish::seat >&
enter_room_rsp::room_users() const {
  return room_users_;
}
inline ::google::protobuf::RepeatedPtrField< ::fish::seat >*
enter_room_rsp::mutable_room_users() {
  return &room_users_;
}

// -------------------------------------------------------------------

// enter_room_notify

// required int32 number = 1;
inline bool enter_room_notify::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void enter_room_notify::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void enter_room_notify::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void enter_room_notify::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 enter_room_notify::number() const {
  return number_;
}
inline void enter_room_notify::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
}

// required string game_id = 2;
inline bool enter_room_notify::has_game_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void enter_room_notify::set_has_game_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void enter_room_notify::clear_has_game_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void enter_room_notify::clear_game_id() {
  if (game_id_ != &::google::protobuf::internal::kEmptyString) {
    game_id_->clear();
  }
  clear_has_game_id();
}
inline const ::std::string& enter_room_notify::game_id() const {
  return *game_id_;
}
inline void enter_room_notify::set_game_id(const ::std::string& value) {
  set_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    game_id_ = new ::std::string;
  }
  game_id_->assign(value);
}
inline void enter_room_notify::set_game_id(const char* value) {
  set_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    game_id_ = new ::std::string;
  }
  game_id_->assign(value);
}
inline void enter_room_notify::set_game_id(const char* value, size_t size) {
  set_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    game_id_ = new ::std::string;
  }
  game_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* enter_room_notify::mutable_game_id() {
  set_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    game_id_ = new ::std::string;
  }
  return game_id_;
}
inline ::std::string* enter_room_notify::release_game_id() {
  clear_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = game_id_;
    game_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void enter_room_notify::set_allocated_game_id(::std::string* game_id) {
  if (game_id_ != &::google::protobuf::internal::kEmptyString) {
    delete game_id_;
  }
  if (game_id) {
    set_has_game_id();
    game_id_ = game_id;
  } else {
    clear_has_game_id();
    game_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// fire_req

// required int32 angle = 1;
inline bool fire_req::has_angle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fire_req::set_has_angle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fire_req::clear_has_angle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fire_req::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline ::google::protobuf::int32 fire_req::angle() const {
  return angle_;
}
inline void fire_req::set_angle(::google::protobuf::int32 value) {
  set_has_angle();
  angle_ = value;
}

// -------------------------------------------------------------------

// fire_rsp

// required int32 state = 1;
inline bool fire_rsp::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fire_rsp::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fire_rsp::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fire_rsp::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 fire_rsp::state() const {
  return state_;
}
inline void fire_rsp::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// fire_notify

// required int32 number = 1;
inline bool fire_notify::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fire_notify::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fire_notify::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fire_notify::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 fire_notify::number() const {
  return number_;
}
inline void fire_notify::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
}

// required int32 angle = 2;
inline bool fire_notify::has_angle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fire_notify::set_has_angle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fire_notify::clear_has_angle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fire_notify::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline ::google::protobuf::int32 fire_notify::angle() const {
  return angle_;
}
inline void fire_notify::set_angle(::google::protobuf::int32 value) {
  set_has_angle();
  angle_ = value;
}

// -------------------------------------------------------------------

// fish_refresh_notify

// required int32 fish_id = 1;
inline bool fish_refresh_notify::has_fish_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fish_refresh_notify::set_has_fish_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fish_refresh_notify::clear_has_fish_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fish_refresh_notify::clear_fish_id() {
  fish_id_ = 0;
  clear_has_fish_id();
}
inline ::google::protobuf::int32 fish_refresh_notify::fish_id() const {
  return fish_id_;
}
inline void fish_refresh_notify::set_fish_id(::google::protobuf::int32 value) {
  set_has_fish_id();
  fish_id_ = value;
}

// required int32 line_id = 2;
inline bool fish_refresh_notify::has_line_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fish_refresh_notify::set_has_line_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fish_refresh_notify::clear_has_line_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fish_refresh_notify::clear_line_id() {
  line_id_ = 0;
  clear_has_line_id();
}
inline ::google::protobuf::int32 fish_refresh_notify::line_id() const {
  return line_id_;
}
inline void fish_refresh_notify::set_line_id(::google::protobuf::int32 value) {
  set_has_line_id();
  line_id_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fish

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fish::cmd>() {
  return ::fish::cmd_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_fish_2eproto__INCLUDED
